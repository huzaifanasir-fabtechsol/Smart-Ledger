import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/google-translate-api-x/lib/defaults.cjs
var require_defaults = __commonJS({
  "node_modules/google-translate-api-x/lib/defaults.cjs"(exports, module) {
    "use strict";
    var TRANSLATE_PATH = "https://translate.google.";
    var DEFAULT_OPTIONS = {
      from: "auto",
      to: "en",
      autoCorrect: false,
      tld: "com",
      requestFunction(url, fetchinit) {
        return fetch(url, fetchinit);
      },
      requestOptions: {
        credentials: "omit",
        headers: {}
      },
      fallbackBatch: true,
      forceBatch: true,
      forceFrom: false,
      forceTo: false,
      rejectOnPartialFail: true
    };
    Object.freeze(DEFAULT_OPTIONS.requestOptions);
    Object.freeze(DEFAULT_OPTIONS);
    module.exports = { DEFAULT_OPTIONS, TRANSLATE_PATH };
  }
});

// node_modules/google-translate-api-x/lib/translation/TranslationResult.cjs
var require_TranslationResult = __commonJS({
  "node_modules/google-translate-api-x/lib/translation/TranslationResult.cjs"(exports, module) {
    "use strict";
    module.exports = class {
      text = "";
      pronunciation = void 0;
      from = {
        language: {
          didYouMean: void 0,
          iso: ""
        },
        text: {
          autoCorrected: void 0,
          value: "",
          didYouMean: void 0
        }
      };
      raw = void 0;
      constructor(raw) {
        this.raw = raw;
      }
    };
  }
});

// node_modules/google-translate-api-x/lib/languages.cjs
var require_languages = __commonJS({
  "node_modules/google-translate-api-x/lib/languages.cjs"(exports, module) {
    "use strict";
    var langs = {
      "auto": "Detect language",
      "auto": "Automatic",
      "ab": "Abkhaz",
      "ace": "Acehnese",
      "ach": "Acholi",
      "aa": "Afar",
      "af": "Afrikaans",
      "sq": "Albanian",
      "alz": "Alur",
      "am": "Amharic",
      "ar": "Arabic",
      "hy": "Armenian",
      "as": "Assamese",
      "av": "Avar",
      "awa": "Awadhi",
      "ay": "Aymara",
      "az": "Azerbaijani",
      "ban": "Balinese",
      "bal": "Baluchi",
      "bm": "Bambara",
      "bci": "Baoulé",
      "ba": "Bashkir",
      "eu": "Basque",
      "btx": "Batak Karo",
      "bts": "Batak Simalungun",
      "bbc": "Batak Toba",
      "be": "Belarusian",
      "bem": "Bemba",
      "bn": "Bengali",
      "bew": "Betawi",
      "bho": "Bhojpuri",
      "bik": "Bikol",
      "bs": "Bosnian",
      "br": "Breton",
      "bg": "Bulgarian",
      "bua": "Buryat",
      "yue": "Cantonese",
      "ca": "Catalan",
      "ceb": "Cebuano",
      "ch": "Chamorro",
      "ce": "Chechen",
      "ny": "Chichewa",
      "zh-CN": "Chinese (Simplified)",
      "zh-TW": "Chinese (Traditional)",
      "chk": "Chuukese",
      "cv": "Chuvash",
      "co": "Corsican",
      "crh": "Crimean Tatar (Cyrillic)",
      "crh-Latn": "Crimean Tatar (Latin)",
      "hr": "Croatian",
      "cs": "Czech",
      "da": "Danish",
      "fa-AF": "Dari",
      "dv": "Dhivehi",
      "din": "Dinka",
      "doi": "Dogri",
      "dov": "Dombe",
      "nl": "Dutch",
      "dyu": "Dyula",
      "dz": "Dzongkha",
      "en": "English",
      "eo": "Esperanto",
      "et": "Estonian",
      "ee": "Ewe",
      "fo": "Faroese",
      "fj": "Fijian",
      "tl": "Filipino",
      "fi": "Finnish",
      "fon": "Fon",
      "fr": "French",
      "fr-CA": "French (Canada)",
      "fy": "Frisian",
      "fur": "Friulian",
      "ff": "Fulani",
      "gaa": "Ga",
      "gl": "Galician",
      "ka": "Georgian",
      "de": "German",
      "el": "Greek",
      "gn": "Guarani",
      "gu": "Gujarati",
      "ht": "Haitian Creole",
      "cnh": "Hakha Chin",
      "ha": "Hausa",
      "haw": "Hawaiian",
      "he": "Hebrew",
      "iw": "Hebrew",
      "hil": "Hiligaynon",
      "hi": "Hindi",
      "hmn": "Hmong",
      "hu": "Hungarian",
      "hrx": "Hunsrik",
      "iba": "Iban",
      "is": "Icelandic",
      "ig": "Igbo",
      "ilo": "Ilocano",
      "id": "Indonesian",
      "iu-Latn": "Inuktut (Latin)",
      "iu": "Inuktut (Syllabics)",
      "ga": "Irish",
      "it": "Italian",
      "jam": "Jamaican Patois",
      "ja": "Japanese",
      "jw": "Javanese",
      "kac": "Jingpo",
      "kl": "Kalaallisut",
      "kn": "Kannada",
      "kr": "Kanuri",
      "pam": "Kapampangan",
      "kk": "Kazakh",
      "kha": "Khasi",
      "km": "Khmer",
      "cgg": "Kiga",
      "kg": "Kikongo",
      "rw": "Kinyarwanda",
      "ktu": "Kituba",
      "trp": "Kokborok",
      "kv": "Komi",
      "gom": "Konkani",
      "ko": "Korean",
      "kri": "Krio",
      "ku": "Kurdish (Kurmanji)",
      "ckb": "Kurdish (Sorani)",
      "ky": "Kyrgyz",
      "lo": "Lao",
      "ltg": "Latgalian",
      "la": "Latin",
      "lv": "Latvian",
      "lij": "Ligurian",
      "li": "Limburgish",
      "ln": "Lingala",
      "lt": "Lithuanian",
      "lmo": "Lombard",
      "lg": "Luganda",
      "luo": "Luo",
      "lb": "Luxembourgish",
      "mk": "Macedonian",
      "mad": "Madurese",
      "mai": "Maithili",
      "mak": "Makassar",
      "mg": "Malagasy",
      "ms": "Malay",
      "ms-Arab": "Malay (Jawi)",
      "ml": "Malayalam",
      "mt": "Maltese",
      "mam": "Mam",
      "gv": "Manx",
      "mi": "Maori",
      "mr": "Marathi",
      "mh": "Marshallese",
      "mwr": "Marwadi",
      "mfe": "Mauritian Creole",
      "chm": "Meadow Mari",
      "mni-Mtei": "Meiteilon (Manipuri)",
      "min": "Minang",
      "lus": "Mizo",
      "mn": "Mongolian",
      "my": "Myanmar (Burmese)",
      "nhe": "Nahuatl (Eastern Huasteca)",
      "ndc-ZW": "Ndau",
      "nr": "Ndebele (South)",
      "new": "Nepalbhasa (Newari)",
      "ne": "Nepali",
      "bm-Nkoo": "NKo",
      "no": "Norwegian",
      "nus": "Nuer",
      "oc": "Occitan",
      "or": "Odia (Oriya)",
      "om": "Oromo",
      "os": "Ossetian",
      "pag": "Pangasinan",
      "pap": "Papiamento",
      "ps": "Pashto",
      "fa": "Persian",
      "pl": "Polish",
      "pt": "Portuguese",
      "pt": "Portuguese (Brazil)",
      "pt-PT": "Portuguese (Portugal)",
      "pa": "Punjabi",
      "pa": "Punjabi (Gurmukhi)",
      "pa-Arab": "Punjabi (Shahmukhi)",
      "qu": "Quechua",
      "kek": "Qʼeqchiʼ",
      "rom": "Romani",
      "ro": "Romanian",
      "rn": "Rundi",
      "ru": "Russian",
      "se": "Sami (North)",
      "sm": "Samoan",
      "sg": "Sango",
      "sa": "Sanskrit",
      "sat-Latn": "Santali (Latin)",
      "sat": "Santali (Ol Chiki)",
      "gd": "Scots Gaelic",
      "nso": "Sepedi",
      "sr": "Serbian",
      "st": "Sesotho",
      "crs": "Seychellois Creole",
      "shn": "Shan",
      "sn": "Shona",
      "scn": "Sicilian",
      "szl": "Silesian",
      "sd": "Sindhi",
      "si": "Sinhala",
      "sk": "Slovak",
      "sl": "Slovenian",
      "so": "Somali",
      "es": "Spanish",
      "su": "Sundanese",
      "sus": "Susu",
      "sw": "Swahili",
      "ss": "Swati",
      "sv": "Swedish",
      "ty": "Tahitian",
      "tg": "Tajik",
      "ber-Latn": "Tamazight",
      "ber": "Tamazight (Tifinagh)",
      "ta": "Tamil",
      "tt": "Tatar",
      "te": "Telugu",
      "tet": "Tetum",
      "th": "Thai",
      "bo": "Tibetan",
      "ti": "Tigrinya",
      "tiv": "Tiv",
      "tpi": "Tok Pisin",
      "to": "Tongan",
      "lua": "Tshiluba",
      "ts": "Tsonga",
      "tn": "Tswana",
      "tcy": "Tulu",
      "tum": "Tumbuka",
      "tr": "Turkish",
      "tk": "Turkmen",
      "tyv": "Tuvan",
      "ak": "Twi",
      "udm": "Udmurt",
      "uk": "Ukrainian",
      "ur": "Urdu",
      "ug": "Uyghur",
      "uz": "Uzbek",
      "ve": "Venda",
      "vec": "Venetian",
      "vi": "Vietnamese",
      "war": "Waray",
      "cy": "Welsh",
      "wo": "Wolof",
      "xh": "Xhosa",
      "sah": "Yakut",
      "yi": "Yiddish",
      "yo": "Yoruba",
      "yua": "Yucatec Maya",
      "zap": "Zapotec",
      "zu": "Zulu"
    };
    function getCode(desiredLang) {
      if (typeof desiredLang !== "string") {
        return null;
      }
      if (langs[desiredLang]) {
        return desiredLang;
      }
      const keys = Object.keys(langs).filter(function(key) {
        if (typeof langs[key] !== "string") {
          return false;
        }
        return langs[key].toLowerCase() === desiredLang.toLowerCase();
      });
      return keys[0] ?? null;
    }
    function isSupported(desiredLang) {
      return getCode(desiredLang) !== null;
    }
    module.exports = { langs, isSupported, getCode };
  }
});

// node_modules/google-translate-api-x/lib/translation/batchTranslate.cjs
var require_batchTranslate = __commonJS({
  "node_modules/google-translate-api-x/lib/translation/batchTranslate.cjs"(exports, module) {
    "use strict";
    var { DEFAULT_OPTIONS, TRANSLATE_PATH } = require_defaults();
    var TranslationResult = require_TranslationResult();
    var { getCode } = require_languages();
    module.exports = function(input, options) {
      options = { ...DEFAULT_OPTIONS, ...options };
      const rpcids = "MkEWBc";
      const queryParams = new URLSearchParams({
        "rpcids": rpcids,
        "source-path": "/",
        "f.sid": "",
        // as far as I can tell, what is input for f.sid and bl doesn't matter
        "bl": "",
        "hl": "en-US",
        "soc-app": 1,
        "soc-platform": 1,
        "soc-device": 1,
        "_reqid": Math.floor(1e3 + Math.random() * 9e3),
        "rt": "c"
      });
      const url = TRANSLATE_PATH + options.tld + "/_/TranslateWebserverUi/data/batchexecute?" + queryParams.toString();
      const requestOptions = { ...options.requestOptions, ...DEFAULT_OPTIONS.requestOptions };
      requestOptions.method = "POST";
      requestOptions.headers["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";
      const sourceArray = Array.isArray(input) ? input : typeof input === "object" ? Object.values(input) : [input];
      let finalResult = Array.isArray(input) ? [] : typeof input === "object" ? {} : void 0;
      const freq = [];
      for (let i = 0; i < sourceArray.length; i++) {
        const text = sourceArray[i].text ?? sourceArray[i];
        const forceFrom = sourceArray[i].forceFrom ?? options.forceFrom;
        const from = sourceArray[i].from ?? options.from;
        const fromIso = forceFrom ? from : getCode(from);
        if (fromIso === null) {
          return new Promise(() => {
            throw new Error(`From language ${from} unsupported, bypass this with setting forceFrom to true if you're certain the iso is correct`, { cause: { options: { from } } });
          });
        }
        const forceTo = sourceArray[i].forceTo ?? options.forceTo;
        const to = sourceArray[i].to ?? options.to;
        const toIso = forceTo ? to : getCode(to);
        if (toIso === null) {
          return new Promise(() => {
            throw new Error(`To language ${to} unsupported, bypass this with setting forceTo to true if you're certain the iso is correct`, { cause: { options: { to } } });
          });
        }
        const autoCorrect = sourceArray[i].autoCorrect ?? options.autoCorrect;
        if (text.length === 0) {
          const result = new TranslationResult(text);
          result.text = text;
          result.from = fromIso;
          result.to = toIso;
          if (Array.isArray(input)) {
            finalResult[i] = result;
          } else if (typeof input === "object") {
            finalResult[Object.keys(input)[i]] = result;
          } else {
            finalResult = result;
          }
          continue;
        }
        const freqPart = [rpcids, JSON.stringify([[text, fromIso, toIso, autoCorrect], [null]]), null, i.toString(36)];
        freq.push(freqPart);
      }
      if (freq.length === 0) {
        return new Promise((resolve) => {
          resolve(finalResult);
        });
      }
      requestOptions.body = "f.req=" + encodeURIComponent(JSON.stringify([freq])) + "&";
      return options.requestFunction(url, requestOptions).then(async (res) => {
        if (!res.ok) {
          throw new Error(res.statusText, { cause: { options, url, response: res } });
        }
        res = await res.text();
        res = res.slice(6);
        for (let chunk of res.split("\n")) {
          if (chunk[0] !== "[" || chunk[3] === "e") {
            continue;
          }
          chunk = JSON.parse(chunk);
          for (let translation of chunk) {
            if (translation[0] !== "wrb.fr") {
              continue;
            }
            const id = parseInt(translation[translation.length - 1], 36);
            if (translation[2] === null) {
              if (!options.rejectOnPartialFail) {
                if (Array.isArray(input)) {
                  finalResult[id] = null;
                } else if (typeof input === "object") {
                  finalResult[Object.keys(input)[id]] = null;
                } else {
                  finalResult = null;
                }
                continue;
              }
              throw new Error(
                "Partial Translation Request Fail: at least one translation failed, it was either invalid or more likely- rejected by the server.  You can try the request again and if it persists try a proxy, spacing out requests, and/or using a different tld.  If you would like to translate other requests in a batch translation even if one fails(the failed translation will be set to `null`) pass the option `rejectOnPartialFail: false`.  You can also try using the singleTranslate endpoint with: `forceBatch: false`",
                { cause: { input, url, options, requestOptions } }
              );
            }
            translation = JSON.parse(translation[2]);
            const result = new TranslationResult(translation);
            if (translation[1][0][0][5] === void 0 || translation[1][0][0][5] === null) {
              result.text = translation[1][0][0][0];
            } else {
              result.text = translation[1][0][0][5].map(function(obj) {
                return obj[0];
              }).filter(Boolean).join(" ");
            }
            result.pronunciation = translation[1][0][0][1] ?? void 0;
            result.from.language.didYouMean = true;
            if (translation[0] && translation[0][1] && translation[0][1][1]) {
              result.from.language.didYouMean = true;
              result.from.language.iso = translation[0][1][1][0];
            } else if (translation[1][3] === "auto") {
              result.from.language.iso = translation[2];
            } else {
              result.from.language.iso = translation[1][3];
            }
            result.from.text.autoCorrected = false;
            result.from.text.didYouMean = false;
            if (translation[0] && translation[0][1] && translation[0][1][0]) {
              let str = translation[0][1][0][0][1];
              str = str.replace(/<b>(<i>)?/g, "[");
              str = str.replace(/(<\/i>)?<\/b>/g, "]");
              result.from.text.value = str;
              if (translation[0][1][0][2] === 1) {
                result.from.text.autoCorrected = true;
              } else {
                result.from.text.didYouMean = true;
              }
            }
            if (Array.isArray(input)) {
              finalResult[id] = result;
            } else if (typeof input === "object") {
              finalResult[Object.keys(input)[id]] = result;
            } else {
              finalResult = result;
            }
          }
        }
        return finalResult;
      });
    };
  }
});

// node_modules/google-translate-api-x/lib/translation/singleTranslate.cjs
var require_singleTranslate = __commonJS({
  "node_modules/google-translate-api-x/lib/translation/singleTranslate.cjs"(exports, module) {
    "use strict";
    var { DEFAULT_OPTIONS, TRANSLATE_PATH } = require_defaults();
    var TranslationResult = require_TranslationResult();
    var { getCode } = require_languages();
    module.exports = function(input, options) {
      options = { ...DEFAULT_OPTIONS, ...options, ...input.options };
      const requestOptions = { ...DEFAULT_OPTIONS.requestOptions, ...options.requestOptions };
      requestOptions.method = "POST";
      requestOptions.headers["Content-Type"] = "application/x-www-form-urlencoded;charset=utf-8";
      const fromIso = options.forceFrom ? options.from : getCode(options.from);
      if (fromIso === null) {
        return new Promise(() => {
          throw new Error(`From language ${options.from} unsupported, bypass this with setting forceFrom to true if you're certain the iso is correct`, { cause: { options } });
        });
      }
      const toIso = options.forceTo ? options.to : getCode(options.to);
      if (toIso === null) {
        return new Promise(() => {
          throw new Error(`To language ${options.to} unsupported, bypass this with setting forceTo to true if you're certain the iso is correct`, { cause: { options } });
        });
      }
      const params = {
        sl: fromIso,
        tl: toIso,
        q: input.text ?? input
      };
      if (params.q.length === 0) {
        return new Promise((resolve) => {
          const result = new TranslationResult(params.q);
          result.from = fromIso;
          result.to = toIso;
          resolve(result);
        });
      }
      requestOptions.body = new URLSearchParams(params).toString();
      const url = TRANSLATE_PATH + options.tld + "/translate_a/single?client=at&dt=t&dt=rm&dj=1";
      return options.requestFunction(url, requestOptions).then((res) => {
        if (res.ok) {
          return res.json();
        }
        throw new Error(res.statusText, { cause: { options, url, response: res } });
      }).then((res) => {
        const result = new TranslationResult(res);
        result.from = res.src ?? options.from;
        result.to = options.to;
        for (const sentence of res.sentences) {
          if (typeof sentence.trans !== "undefined") {
            result.text += sentence.trans;
          } else if (typeof sentence.translit !== "undefined") {
            result.pronunciation = sentence.translit;
          }
        }
        return result;
      });
    };
  }
});

// node_modules/google-translate-api-x/lib/translation/translate.cjs
var require_translate = __commonJS({
  "node_modules/google-translate-api-x/lib/translation/translate.cjs"(exports, module) {
    "use strict";
    var { DEFAULT_OPTIONS } = require_defaults();
    var batchTranslate = require_batchTranslate();
    var singleTranslate = require_singleTranslate();
    module.exports = function(input, options) {
      options = { ...DEFAULT_OPTIONS, ...options };
      if (typeof input === "string" && !options.forceBatch) {
        return singleTranslate(input, options).catch((e) => {
          if (options.fallbackBatch) {
            return batchTranslate(input, options);
          }
          throw e;
        });
      }
      return batchTranslate(input, options);
    };
  }
});

// node_modules/google-translate-api-x/lib/translation/Translator.cjs
var require_Translator = __commonJS({
  "node_modules/google-translate-api-x/lib/translation/Translator.cjs"(exports, module) {
    "use strict";
    var { DEFAULT_OPTIONS } = require_defaults();
    var translate = require_translate();
    module.exports = class {
      options;
      constructor(options) {
        this.options = { ...DEFAULT_OPTIONS, ...options };
      }
      translate(input, options) {
        options = { ...this.options, ...options };
        return translate(input, options);
      }
    };
  }
});

// node_modules/google-translate-api-x/lib/speak.cjs
var require_speak = __commonJS({
  "node_modules/google-translate-api-x/lib/speak.cjs"(exports, module) {
    "use strict";
    var { DEFAULT_OPTIONS, TRANSLATE_PATH } = require_defaults();
    var { getCode } = require_languages();
    module.exports = function(input, options) {
      options = { ...DEFAULT_OPTIONS, ...options };
      const rpcids = "jQ1olc";
      const queryParams = new URLSearchParams({
        "rpcids": rpcids,
        "source-path": "/",
        "f.sid": "",
        "bl": "",
        "hl": "en-US",
        "soc-app": 1,
        "soc-platform": 1,
        "soc-device": 1,
        "_reqid": Math.floor(1e3 + Math.random() * 9e3),
        "rt": "c"
      });
      const url = TRANSLATE_PATH + options.tld + "/_/TranslateWebserverUi/data/batchexecute?" + queryParams.toString();
      const requestOptions = { ...options.requestOptions, ...DEFAULT_OPTIONS.requestOptions };
      requestOptions.method = "POST";
      requestOptions.headers["Content-Type"] = "application/x-www-form-urlencoded;charset=UTF-8";
      const sourceArray = Array.isArray(input) ? input : typeof input === "object" ? Object.values(input) : [input];
      const freq = [];
      for (let i = 0; i < sourceArray.length; i++) {
        const text = sourceArray[i].text ?? sourceArray[i];
        if (text.length > 200) {
          return new Promise(() => {
            throw new Error("At least one of the inputs exceeded 200 characters, which is rejected by Google translate.  You should split it into a batch input with arrays/objects.", { cause: { input: { text } } });
          });
        }
        const forceTo = sourceArray[i].forceTo ?? options.forceTo;
        const to = sourceArray[i].to ?? options.to;
        const toIso = forceTo ? to : getCode(to);
        if (toIso === null) {
          return new Promise(() => {
            throw new Error(`To language ${to} unsupported, bypass this with setting forceTo to true if you're certain the iso is correct`, { cause: { options: { to } } });
          });
        }
        const freqPart = [rpcids, JSON.stringify([text, toIso, true]), null, i.toString(36)];
        freq.push(freqPart);
      }
      requestOptions.body = "f.req=" + encodeURIComponent(JSON.stringify([freq])) + "&";
      return options.requestFunction(url, requestOptions).then(async (res) => {
        if (!res.ok) {
          throw new Error(res.statusText, { cause: { options, url, response: res } });
        }
        res = await res.text();
        res = res.slice(6);
        let finalResult = Array.isArray(input) ? [] : typeof input === "object" ? {} : void 0;
        for (let chunk of res.split("\n")) {
          if (chunk[0] !== "[" || chunk[3] === "e") {
            continue;
          }
          chunk = JSON.parse(chunk);
          for (let translation of chunk) {
            if (translation[0] !== "wrb.fr") {
              continue;
            }
            const id = parseInt(translation[translation.length - 1], 36);
            if (translation[2] === null && options.rejectOnPartialFail) {
              throw new Error(
                "Partial TTS Request Fail: at least one TTS request failed, it was either invalid or more likely- rejected by the server.  You can try the request again and if it persists try a proxy, spacing out requests, and/or using a different tld.  If you would like to still speak other requests in a batch speak request even if one fails(the failed TTS will be set to `null`) pass the option `rejectOnPartialFail: false`",
                { cause: { input, url, options, requestOptions } }
              );
            }
            const result = translation[2] !== null ? JSON.parse(translation[2])[0] : null;
            if (Array.isArray(input)) {
              finalResult[id] = result;
            } else if (typeof input === "object") {
              finalResult[Object.keys(input)[id]] = result;
            } else {
              finalResult = result;
            }
          }
        }
        return finalResult;
      });
    };
  }
});

// node_modules/google-translate-api-x/index.cjs
var require_google_translate_api_x = __commonJS({
  "node_modules/google-translate-api-x/index.cjs"(exports, module) {
    var translate = require_translate();
    var Translator = require_Translator();
    var singleTranslate = require_singleTranslate();
    var batchTranslate = require_batchTranslate();
    var { langs, isSupported, getCode } = require_languages();
    var speak = require_speak();
    module.exports = translate;
    module.exports.translate = translate;
    module.exports.Translator = Translator;
    module.exports.singleTranslate = singleTranslate;
    module.exports.batchTranslate = batchTranslate;
    module.exports.languages = langs;
    module.exports.isSupported = isSupported;
    module.exports.getCode = getCode;
    module.exports.speak = speak;
  }
});
export default require_google_translate_api_x();
//# sourceMappingURL=google-translate-api-x.js.map
